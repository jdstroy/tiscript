CC = cl.exe
LD = link.exe

#CFLAGS = $(CFLAGS) /showIncludes

VALID_TARGET=no
!if "$(TARGET)"=="rel"
OUTDIR=obj-rel-win
CFLAGS = $(CFLAGS) /D "NDEBUG" /D "_SECURE_CSL=0" /MD /Ox /Os
VALID_TARGET=yes
!endif

!if "$(TARGET)"=="dbg"
OUTDIR=obj-dbg-win
CFLAGS = $(CFLAGS) /D "_DEBUG" /MDd /Od
VALID_TARGET=yes
!endif

O=$(OUTDIR)

CFLAGS = $(CFLAGS) /nologo /c
# standard windows defines
CFLAGS = $(CFLAGS) /D "WIN32" /D "_WIN32_WINNT=0x0500"
#CFLAGS = $(CFLAGS) /D "WIN32_LEAN_AND_MEAN"
#CFLAGS = $(CFLAGS) /D "UNICODE" /D "_UNICODE"
#CFLAGS = $(CFLAGS) /D "_SCL_SECURE_NO_DEPRECATE" /D "_CRT_SECURE_NO_DEPRECATE"
CFLAGS = $(CFLAGS) /D "_CRT_SECURE_NO_WARNINGS"
#CFLAGS = $(CFLAGS) /wd4244 /wd4018

CFLAGS = $(CFLAGS) /W3
# /GR- : disable C++ RTTI
CFLAGS = $(CFLAGS) /GR-
CFLAGS = $(CFLAGS) /EHsc
CFLAGS = $(CFLAGS) /Zi

CFLAGS = $(CFLAGS) /Iinclude /Itool /Idybase/inc /Iregexp

LIBS = $(LIBS) kernel32.lib advapi32.lib

LDFLAGS = $(LDFLAGS) /nologo /DEBUG

# tool
OBJS=$(O)\snprintf.obj $(O)\tl_base64.obj $(O)\tl_basic.obj $(O)\tl_datetime.obj \
  $(O)\tl_mm_file.obj $(O)\tl_string.obj $(O)\tl_url.obj $(O)\tl_ustring.obj \
  $(O)\tl_util.obj
# int
OBJS = $(OBJS) $(O)\cs_bytevector.obj $(O)\cs_cobject.obj $(O)\cs_datetime.obj \
  $(O)\cs_debug.obj $(O)\cs_enter.obj $(O)\cs_env.obj \
  $(O)\cs_error.obj $(O)\cs_fcn.obj \
  $(O)\cs_file.obj $(O)\cs_float.obj $(O)\cs_hash.obj $(O)\cs_heap.obj \
  $(O)\cs_instanceof.obj $(O)\cs_int.obj $(O)\cs_integer.obj $(O)\cs_math.obj \
  $(O)\cs_method.obj $(O)\cs_object.obj $(O)\cs_parse.obj $(O)\cs_persistent.obj \
  $(O)\cs_printf.obj $(O)\cs_rcode.obj $(O)\cs_regexp.obj $(O)\cs_storage.obj \
  $(O)\cs_stream.obj $(O)\cs_string.obj $(O)\cs_symbol.obj $(O)\cs_system.obj $(O)\cs_type.obj \
  $(O)\cs_vector.obj $(O)\cs_xml_parser.obj $(O)\json_cvt.obj
# int\sockio
OBJS = $(OBJS) $(O)\w32sock.obj
# com
OBJS = $(OBJS) $(O)\cs_com.obj $(O)\cs_eval.obj $(O)\cs_scn.obj $(O)\cs_wcode.obj
# regexp
OBJS = $(OBJS) $(O)\frontend.obj $(O)\memory.obj $(O)\regerror.obj $(O)\regexp.obj \
  $(O)\regsub.obj $(O)\widechar.obj $(O)\wregexp.obj
# dybase\src
OBJS = $(OBJS) $(O)\btree.obj $(O)\database.obj $(O)\dybase.obj $(O)\file.obj $(O)\pagepool.obj
# .
OBJS = $(OBJS) $(O)\main.obj

TISCRIPT_EXE=$(O)\tiscript.exe
TISCRIPT_PDB=$(O)\tiscript.pdb
TISCRIPT_OBJS=$(OBJS)

!if "$(VALID_TARGET)"=="yes"
all: $(OUTDIR) $(TISCRIPT_EXE)
$(OUTDIR): force
	@if not exist $(OUTDIR) mkdir $(OUTDIR)
clean: force
	-rmdir /S /Q $(OUTDIR)
!else
all clean: force
	@echo TARGET must be set to dbg or rel
!endif

$(TISCRIPT_EXE): $(TISCRIPT_OBJS)
	$(LD) $(LDFLAGS) /OUT:$@ \
	/PDB:$(TISCRIPT_PDB) \
	$** $(LIBS) /SUBSYSTEM:CONSOLE /MACHINE:X86

{regexp\}.c{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{regexp\}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{com\}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{dybase\src\}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{int\}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{int\sockio}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

{tool\}.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

.cpp{$(OUTDIR)}.obj::
	$(CC) $(CFLAGS) -Fo$(OUTDIR)\ $<

force: ;
